# How `[ConditionalFunction]` Works

The `[ConditionalFunction]` attribute is one of the **coolest features** of your Toolkit architecture. It allows functions to **appear or disappear** from the AI's available tools based on runtime configuration!

## ğŸ¯ The Problem It Solves

Imagine you have a FileSystem Toolkit, but you want different configurations for different scenarios:

- **Development environment**: Full access to search (glob, grep)
- **Production environment**: Only basic file read/write, **no search** (security!)
- **Restricted environment**: Read-only mode

Without `[ConditionalFunction]`, you'd need to:
1. Create multiple Toolkit classes, OR
2. Always expose all functions (even when they shouldn't be used)

With `[ConditionalFunction]`, functions **dynamically appear/disappear** based on context!

---

## ğŸ“ How It Works: Step by Step

### **Step 1: Define Your Context**

```csharp
public class FileSystemContext : IToolkitMetadata
{
    public bool EnableSearch { get; }  // â† The magic property!

    public FileSystemContext(bool enableSearch = true)
    {
        EnableSearch = enableSearch;
    }
}
```

### **Step 2: Mark Functions as Conditional**

```csharp
public partial class FileSystemToolkit
{
    //  Always available (no condition)
    [AIFunction<FileSystemContext>]
    public Task<string> ReadFile(string path) { ... }

    // âš¡ Only available when EnableSearch = true
    [AIFunction<FileSystemContext>]
    [ConditionalFunction("EnableSearch")]  // â† The conditional attribute!
    public Task<string> FindFiles(string pattern) { ... }

    // âš¡ Only available when EnableSearch = true
    [AIFunction<FileSystemContext>]
    [ConditionalFunction("EnableSearch")]
    public Task<string> SearchContent(string pattern) { ... }
}
```

### **Step 3: Runtime Behavior**

#### **Scenario A: Development (Search Enabled)**
```csharp
var context = new FileSystemContext(enableSearch: true);
var functions = ToolkitManager.CreateAllFunctions(context);

// Result: AI sees ALL 3 functions
//  ReadFile
//  FindFiles      â† Available!
//  SearchContent  â† Available!
```

#### **Scenario B: Production (Search Disabled)**
```csharp
var context = new FileSystemContext(enableSearch: false);
var functions = ToolkitManager.CreateAllFunctions(context);

// Result: AI sees ONLY 1 function
//  ReadFile
//    FindFiles      â† Hidden! (condition failed)
//    SearchContent  â† Hidden! (condition failed)
```

---

## ğŸ”§ Under the Hood: Source Generator Magic

When you write this code:

```csharp
[AIFunction<FileSystemContext>]
[ConditionalFunction("EnableSearch")]
public Task<string> FindFiles(string pattern) { ... }
```

Your **source generator** creates this at compile time:

```csharp
// Generated by HPDToolkitSourceGenerator
private static bool EvaluateFindFilesCondition(IToolkitMetadata? context)
{
    if (context == null) return true;

    if (context is not FileSystemContext typedMetadata)
        return false;

    try
    {
        // Evaluating: EnableSearch
        return typedMetadata.EnableSearch;  // â† Checks the property!
    }
    catch (Exception ex)
    {
        // Expression 'EnableSearch' failed: {ex.Message}
        return false;
    }
}

// Then in the registration code:
public static List<AIFunction> CreateAllFunctions(IToolkitMetadata? context)
{
    var functions = new List<AIFunction>();

    // Always add ReadFile (no condition)
    functions.Add(CreateReadFileFunction(...));

    // Only add FindFiles if condition passes
    if (EvaluateFindFilesCondition(context))  // â† Runtime check!
    {
        functions.Add(CreateFindFilesFunction(...));
    }

    // Only add SearchContent if condition passes
    if (EvaluateSearchContentCondition(context))  // â† Runtime check!
    {
        functions.Add(CreateSearchContentFunction(...));
    }

    return functions;
}
```

---

## ğŸ’¡ Advanced Expressions

The condition can be more complex than just a single property:

### **Simple Boolean**
```csharp
[ConditionalFunction("EnableSearch")]
```
 Checks if `context.EnableSearch == true`

### **Comparison**
```csharp
[ConditionalFunction("MaxFileSize > 1000000")]
```
 Only available if max file size > 1MB

### **Complex Logic**
```csharp
[ConditionalFunction("EnableSearch && AllowAdvanced")]
```
 Both conditions must be true

```csharp
[ConditionalFunction("ProviderCount > 0")]
```
 Only available if at least one provider configured

---

## ğŸŒŸ Real-World Example: Your WebSearch Toolkit

Let's look at how you're already using this in your **WebSearchToolkit**:

```csharp
public class WebSearchContext : IToolkitMetadata
{
    public bool HasTavilyProvider { get; private set; }
    public bool HasBraveProvider { get; private set; }
    public string DefaultProvider { get; private set; }
}

[AIFunction<WebSearchContext>]
[ConditionalFunction("HasTavilyProvider")]  // Only if Tavily is configured!
[AIDescription("Get AI-generated answers using Tavily's answer API")]
public async Task<string> AnswerSearch(string query)
{
    // This function ONLY appears when Tavily is available
}
```

**Why this is powerful:**

User configures context:
```csharp
// User A: Has Tavily API key
var contextA = new WebSearchContext(hasTavily: true, hasBrave: false);
var functionsA = CreateAllFunctions(contextA);
// Result: AI sees AnswerSearch  

// User B: No Tavily, only Brave
var contextB = new WebSearchContext(hasTavily: false, hasBrave: true);
var functionsB = CreateAllFunctions(contextB);
// Result: AI does NOT see AnswerSearch   
```

The AI **automatically adapts** to what's available!

---

## ğŸ”’ Security Use Case

This is **especially important for security**:

```csharp
public class FileSystemContext
{
    public bool AllowDelete { get; }  // Dangerous!
    public bool AllowOutsideWorkspace { get; }  // Very dangerous!
}

[AIFunction<FileSystemContext>]
[ConditionalFunction("AllowDelete")]
[RequiresPermission]
public Task<string> DeleteFile(string path)
{
    // Only available if explicitly enabled
}

[AIFunction<FileSystemContext>]
[ConditionalFunction("AllowOutsideWorkspace")]
[RequiresPermission]
public Task<string> ReadFileOutsideWorkspace(string path)
{
    // Only available in development/trusted environments
}
```

Now you can have:
- **Production config**: `AllowDelete = false` â†’ Delete function doesn't exist!
- **Development config**: `AllowDelete = true` â†’ Delete function is available

---

##  Benefits

1. **Type-Safe** - Validated at compile time by your source generator
2. **Zero Runtime Overhead** - Condition evaluated once when creating functions
3. **AOT Compatible** - No reflection, pure generated code
4. **User-Friendly** - AI only sees functions it can actually use
5. **Secure** - Dangerous functions can be completely hidden

---

## ğŸ¨ Expression Language Features

Your DSL validator ([DSLValidator.cs](../../HPD-Agent.SourceGenerator/Security/DSLValidator.cs)) supports:

### **Allowed Patterns:**
-  Property access: `EnableSearch`, `HasProvider`
-  Comparisons: `Count > 5`, `Size >= 1000`
-  Boolean logic: `A && B`, `C || D`, `!E`
-  Complex: `(HasA || HasB) && Count > 0`

### **Security Blocked:**
-    Method calls: `GetType()`, `LoadAssembly()`
-    Reflection: `typeof()`, `nameof()`
-    Dangerous namespaces: `System.IO`, `System.Reflection`
-    Code injection: `eval()`, SQL commands

All validated at **compile time** for maximum safety!

---

## ğŸ“Š Visual Flow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  1. You Write Code                                          â”‚
â”‚                                                             â”‚
â”‚  [ConditionalFunction("EnableSearch")]                     â”‚
â”‚  public Task<string> FindFiles(...) { }                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
                  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  2. Source Generator (Compile Time)                         â”‚
â”‚                                                             â”‚
â”‚  â€¢ Finds [ConditionalFunction] attribute                   â”‚
â”‚  â€¢ Validates "EnableSearch" exists in FileSystemContext    â”‚
â”‚  â€¢ Generates EvaluateFindFilesCondition() method           â”‚
â”‚  â€¢ Generates registration code with if check               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
                  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  3. Runtime (User Creates Context)                          â”‚
â”‚                                                             â”‚
â”‚  var context = new FileSystemContext(enableSearch: false); â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
                  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  4. Create Functions                                        â”‚
â”‚                                                             â”‚
â”‚  CreateAllFunctions(context):                              â”‚
â”‚    - ReadFile:  Always added                             â”‚
â”‚    - FindFiles:    Skipped (EnableSearch = false)          â”‚
â”‚    - SearchContent:    Skipped (EnableSearch = false)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
                  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  5. AI Agent                                                â”‚
â”‚                                                             â”‚
â”‚  Available tools: [ReadFile]                               â”‚
â”‚  (FindFiles and SearchContent are invisible!)              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸš€ Summary

`[ConditionalFunction]` is a **compile-time + runtime feature** that:

1. **At Compile Time**: Source generator validates expressions and generates conditional code
2. **At Runtime**: Functions appear/disappear based on context property values
3. **For the AI**: It sees a smaller, focused set of tools based on what's actually available

This makes your Toolkit system:
- **Flexible** - Same Toolkit, different configurations
- **Secure** - Hide dangerous functions by default
- **Smart** - AI doesn't waste time with unavailable features
- **Type-safe** - All validated at compile time

Pretty cool, right? ğŸ‰
