using System.Collections.Concurrent;

namespace HPD.MultiAgent.Observability;

/// <summary>
/// Aggregated metrics for a workflow execution.
/// </summary>
public sealed class WorkflowMetrics
{
    /// <summary>
    /// Unique execution ID for this workflow run.
    /// </summary>
    public required string ExecutionId { get; init; }

    /// <summary>
    /// Name of the workflow (if configured).
    /// </summary>
    public string? WorkflowName { get; init; }

    /// <summary>
    /// When the workflow started.
    /// </summary>
    public DateTimeOffset StartedAt { get; init; }

    /// <summary>
    /// When the workflow completed (null if still running).
    /// </summary>
    public DateTimeOffset? CompletedAt { get; set; }

    /// <summary>
    /// Total duration of the workflow.
    /// </summary>
    public TimeSpan Duration => CompletedAt.HasValue
        ? CompletedAt.Value - StartedAt
        : DateTimeOffset.UtcNow - StartedAt;

    /// <summary>
    /// Whether the workflow completed successfully.
    /// </summary>
    public bool? Success { get; set; }

    /// <summary>
    /// Error message if the workflow failed.
    /// </summary>
    public string? ErrorMessage { get; set; }

    /// <summary>
    /// Metrics for each node that executed.
    /// </summary>
    public ConcurrentDictionary<string, NodeMetrics> NodeMetrics { get; } = new();

    /// <summary>
    /// Total number of nodes executed.
    /// </summary>
    public int TotalNodesExecuted => NodeMetrics.Count;

    /// <summary>
    /// Number of nodes that succeeded.
    /// </summary>
    public int SuccessfulNodes => NodeMetrics.Values.Count(n => n.Success == true);

    /// <summary>
    /// Number of nodes that failed.
    /// </summary>
    public int FailedNodes => NodeMetrics.Values.Count(n => n.Success == false);

    /// <summary>
    /// Number of nodes that were skipped.
    /// </summary>
    public int SkippedNodes => NodeMetrics.Values.Count(n => n.WasSkipped);

    /// <summary>
    /// Total tokens used across all nodes (input + output).
    /// </summary>
    public int TotalTokens => NodeMetrics.Values.Sum(n => n.TotalTokens);

    /// <summary>
    /// Total input tokens across all nodes.
    /// </summary>
    public int TotalInputTokens => NodeMetrics.Values.Sum(n => n.InputTokens);

    /// <summary>
    /// Total output tokens across all nodes.
    /// </summary>
    public int TotalOutputTokens => NodeMetrics.Values.Sum(n => n.OutputTokens);

    /// <summary>
    /// Total tool calls across all nodes.
    /// </summary>
    public int TotalToolCalls => NodeMetrics.Values.Sum(n => n.ToolCallCount);

    /// <summary>
    /// Number of iterations (for cyclic graphs).
    /// </summary>
    public int IterationCount { get; set; }

    /// <summary>
    /// Custom tags for filtering/grouping metrics.
    /// </summary>
    public Dictionary<string, string> Tags { get; } = new();

    /// <summary>
    /// Get or create metrics for a specific node.
    /// </summary>
    public NodeMetrics GetOrCreateNodeMetrics(string nodeId)
    {
        return NodeMetrics.GetOrAdd(nodeId, id => new NodeMetrics { NodeId = id });
    }
}

/// <summary>
/// Metrics for a single node execution.
/// </summary>
public sealed class NodeMetrics
{
    /// <summary>
    /// Node ID.
    /// </summary>
    public required string NodeId { get; init; }

    /// <summary>
    /// When the node started executing.
    /// </summary>
    public DateTimeOffset? StartedAt { get; set; }

    /// <summary>
    /// When the node completed.
    /// </summary>
    public DateTimeOffset? CompletedAt { get; set; }

    /// <summary>
    /// Duration of node execution.
    /// </summary>
    public TimeSpan? Duration { get; set; }

    /// <summary>
    /// Whether the node completed successfully.
    /// </summary>
    public bool? Success { get; set; }

    /// <summary>
    /// Whether the node was skipped.
    /// </summary>
    public bool WasSkipped { get; set; }

    /// <summary>
    /// Skip reason if skipped.
    /// </summary>
    public string? SkipReason { get; set; }

    /// <summary>
    /// Error message if failed.
    /// </summary>
    public string? ErrorMessage { get; set; }

    /// <summary>
    /// Number of retry attempts.
    /// </summary>
    public int RetryCount { get; set; }

    /// <summary>
    /// Input tokens used by this node.
    /// </summary>
    public int InputTokens { get; set; }

    /// <summary>
    /// Output tokens generated by this node.
    /// </summary>
    public int OutputTokens { get; set; }

    /// <summary>
    /// Total tokens (input + output).
    /// </summary>
    public int TotalTokens => InputTokens + OutputTokens;

    /// <summary>
    /// Number of tool calls made by this node.
    /// </summary>
    public int ToolCallCount { get; set; }

    /// <summary>
    /// Names of tools called.
    /// </summary>
    public List<string> ToolsCalled { get; } = new();

    /// <summary>
    /// Whether this node required approval.
    /// </summary>
    public bool RequiredApproval { get; set; }

    /// <summary>
    /// Whether approval was granted (if required).
    /// </summary>
    public bool? ApprovalGranted { get; set; }

    /// <summary>
    /// Time spent waiting for approval.
    /// </summary>
    public TimeSpan? ApprovalWaitTime { get; set; }

    /// <summary>
    /// Which iteration this node executed in (for cyclic graphs).
    /// </summary>
    public int Iteration { get; set; }

    /// <summary>
    /// Custom metadata for this node execution.
    /// </summary>
    public Dictionary<string, object> Metadata { get; } = new();
}
