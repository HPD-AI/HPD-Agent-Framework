# Frontend Tools

Frontend Tools are tools provided by the client application (IDE extension, web UI, mobile app) at runtime. They enable human-in-the-loop interactions where the agent requests actions that the frontend executes.

## What Are Frontend Tools?

Unlike C# plugins (server-side) or MCP servers (external processes), Frontend Tools are:
- **Defined by the client** at runtime
- **Executed by the client** (not the server)
- **Human-in-the-loop** - the user sees and controls what happens

```
Agent: "I need to open a file"
    │
    ▼
Frontend Tool Request ──► Client Application
    │                         │
    │                    User sees action
    │                         │
    ◄─────────────────── Tool Result
    │
Agent: "File opened successfully"
```

Common use cases:
- Open files in an IDE
- Show dialogs to the user
- Get user's current selection
- Navigate to URLs
- Display previews

---

## Quick Start

### 1. Enable Frontend Tools

```csharp
var agent = new AgentBuilder()
    .WithFrontendTools()
    .Build();
```

### 2. Provide Tools at Runtime

Tools are provided through `AgentRunInput`:

```csharp
var runInput = new AgentRunInput
{
    FrontendPlugins = new[]
    {
        new FrontendPluginDefinition(
            Name: "IDE",
            Description: "IDE interaction tools",
            Tools: new[]
            {
                new FrontendToolDefinition(
                    Name: "OpenFile",
                    Description: "Open a file in the editor",
                    ParametersSchema: JsonDocument.Parse(@"{
                        ""type"": ""object"",
                        ""properties"": {
                            ""path"": { ""type"": ""string"", ""description"": ""File path"" }
                        },
                        ""required"": [""path""]
                    }").RootElement
                )
            }
        )
    }
};

await foreach (var evt in agent.RunAsync("Open the config file", thread, runInput))
{
    // Handle events...
}
```

### 3. Handle Tool Invocations

Listen for `FrontendToolInvokeRequestEvent` and respond:

```csharp
await foreach (var evt in agent.RunAsync(message, thread, runInput))
{
    if (evt is FrontendToolInvokeRequestEvent request)
    {
        // Execute the tool (client-side)
        var result = await ExecuteToolAsync(request.ToolName, request.Arguments);

        // Send response back
        await agent.SendEventAsync(new FrontendToolInvokeResponseEvent(
            RequestId: request.RequestId,
            Content: new[] { new TextContent(result) },
            Success: true
        ));
    }
}
```

---

## Plugin Definition

Frontend tools are organized into **plugins**:

```csharp
public record FrontendPluginDefinition(
    string Name,                    // Plugin identifier
    string? Description,            // Shown when collapsed
    IReadOnlyList<FrontendToolDefinition> Tools,
    IReadOnlyList<FrontendSkillDefinition>? Skills = null,
    string? FunctionResult = null,  // One-time message on expansion
    string? SystemPrompt = null,    // Persistent instructions
    bool StartCollapsed = true      // Hide behind container initially
);
```

### Tool Definition

```csharp
public record FrontendToolDefinition(
    string Name,                    // Unique tool name
    string Description,             // Shown to agent
    JsonElement ParametersSchema,   // JSON Schema for parameters
    bool RequiresPermission = false // Require user approval
);
```

### Example: IDE Plugin

```csharp
new FrontendPluginDefinition(
    Name: "IDE",
    Description: "VS Code interaction tools",
    StartCollapsed: true,
    // Auto-generated: "IDE expanded. Available functions: OpenFile, GetSelection, ShowMessage"
    FunctionResult: null,  // Auto-generated message is sufficient
    SystemPrompt: "Use ShowMessage for important notifications to the user.",
    Tools: new[]
    {
        new FrontendToolDefinition(
            Name: "OpenFile",
            Description: "Open a file in the editor",
            ParametersSchema: ParseSchema(@"{
                ""type"": ""object"",
                ""properties"": {
                    ""path"": { ""type"": ""string"" },
                    ""line"": { ""type"": ""integer"" }
                },
                ""required"": [""path""]
            }")
        ),
        new FrontendToolDefinition(
            Name: "GetSelection",
            Description: "Get the user's current text selection",
            ParametersSchema: ParseSchema(@"{ ""type"": ""object"" }")
        ),
        new FrontendToolDefinition(
            Name: "ShowMessage",
            Description: "Show a message to the user",
            ParametersSchema: ParseSchema(@"{
                ""type"": ""object"",
                ""properties"": {
                    ""message"": { ""type"": ""string"" },
                    ""severity"": { ""type"": ""string"", ""enum"": [""info"", ""warning"", ""error""] }
                },
                ""required"": [""message""]
            }")
        )
    }
)
```

---

## Collapsing

By default, frontend plugins start collapsed (`StartCollapsed = true`). This groups all tools under a container:

```
Before expansion:        After expansion:
┌──────────────────┐     ┌──────────────────┐
│ IDE              │ ──► │ OpenFile         │
│ (3 tools)        │     │ GetSelection     │
└──────────────────┘     │ ShowMessage      │
                         └──────────────────┘
```

### Control Collapsing Globally

```csharp
var config = new AgentConfig
{
    Collapsing = new CollapsingConfig
    {
        CollapseFrontendTools = true,  // Enable collapsing
        FrontendToolsInstructions = "These tools interact with the user's IDE."
    }
};
```

### Control Per-Plugin

```csharp
new FrontendPluginDefinition(
    Name: "CriticalTools",
    StartCollapsed: false,  // Always visible
    Tools: ...
)
```

### Pre-Expand Plugins

```csharp
var runInput = new AgentRunInput
{
    FrontendPlugins = plugins,
    ExpandedContainers = new HashSet<string> { "IDE" }  // Start expanded
};
```

---

## Instructions

Provide guidance when plugins expand using dual-context architecture:

| Parameter | Location | Lifetime | Use For |
|-----------|----------|----------|---------|
| `FunctionResult` | Conversation history | One-time on expansion | *Additional* context (appended to auto-generated message) |
| `SystemPrompt` | System prompt | Every turn while expanded | Critical rules, workflow |

> **Important:** The system automatically generates a base expansion message:
> ```
> "{PluginName} expanded. Available functions: {FunctionList}"
> ```
> Your `FunctionResult` is **appended** to this auto-generated message. Don't duplicate the expansion info—use it only for additional context. Pass `null` if the auto-generated message is sufficient.

### FunctionResult (One-Time, Appended)

```csharp
new FrontendPluginDefinition(
    Name: "IDE",
    // Auto-generated: "IDE expanded. Available functions: OpenFile, GetSelection, ShowMessage"
    FunctionResult: "Tip: Use GetSelection before making edits.",  // Additional context only
    ...
)
```

### SystemPrompt (Persistent)

```csharp
new FrontendPluginDefinition(
    Name: "IDE",
    SystemPrompt: @"
        IDE RULES:
        - Always confirm before modifying files
        - Use ShowMessage for important notifications
        - Check selection before applying edits",
    ...
)
```

### Global Frontend Instructions

```csharp
var config = new AgentConfig
{
    Collapsing = new CollapsingConfig
    {
        FrontendToolsInstructions = "These tools interact with the user. Be respectful of their time."
    }
};
```

---

## Handling Tool Invocations

### Request Event

When the agent calls a frontend tool:

```csharp
public record FrontendToolInvokeRequestEvent(
    string RequestId,       // Correlation ID (must match in response)
    string ToolName,        // Which tool to execute
    string CallId,          // LLM's function call ID
    IReadOnlyDictionary<string, object?> Arguments,
    string? Description
);
```

### Response Event

Send back the result:

```csharp
public record FrontendToolInvokeResponseEvent(
    string RequestId,       // Must match request
    IReadOnlyList<IToolResultContent> Content,
    bool Success = true,
    string? ErrorMessage = null,
    FrontendToolAugmentation? Augmentation = null
);
```

### Result Content Types

```csharp
// Text result
new TextContent("File opened successfully")

// JSON result
new JsonContent(JsonDocument.Parse(@"{ ""line"": 42, ""column"": 10 }").RootElement)

// Binary result (file, image, etc.)
new BinaryContent(
    MimeType: "image/png",
    Data: base64EncodedData,
    Filename: "screenshot.png"
)
```

### Example Handler

```csharp
await foreach (var evt in agent.RunAsync(message, thread, runInput))
{
    switch (evt)
    {
        case FrontendToolInvokeRequestEvent request:
            try
            {
                var result = request.ToolName switch
                {
                    "OpenFile" => await OpenFileAsync(request.Arguments["path"]?.ToString()),
                    "GetSelection" => await GetSelectionAsync(),
                    "ShowMessage" => await ShowMessageAsync(request.Arguments),
                    _ => throw new NotSupportedException($"Unknown tool: {request.ToolName}")
                };

                await agent.SendEventAsync(new FrontendToolInvokeResponseEvent(
                    RequestId: request.RequestId,
                    Content: new[] { new TextContent(result) },
                    Success: true
                ));
            }
            catch (Exception ex)
            {
                await agent.SendEventAsync(new FrontendToolInvokeResponseEvent(
                    RequestId: request.RequestId,
                    Content: Array.Empty<IToolResultContent>(),
                    Success: false,
                    ErrorMessage: ex.Message
                ));
            }
            break;

        case TextDeltaEvent delta:
            Console.Write(delta.Text);
            break;
    }
}
```

---

## Dynamic State Changes (Augmentation)

Tool responses can modify the agent's state:

```csharp
await agent.SendEventAsync(new FrontendToolInvokeResponseEvent(
    RequestId: request.RequestId,
    Content: new[] { new TextContent("User logged in") },
    Augmentation: new FrontendToolAugmentation
    {
        // Add new plugins
        InjectPlugins = new[] { adminPlugin },

        // Remove plugins
        RemovePlugins = new HashSet<string> { "LoginTools" },

        // Control expansion
        ExpandPlugins = new HashSet<string> { "AdminTools" },
        CollapsePlugins = new HashSet<string> { "GuestTools" },

        // Control visibility
        HideTools = new HashSet<string> { "Login" },
        ShowTools = new HashSet<string> { "Logout" },

        // Update context
        AddContext = new[] { new ContextItem("user", "Admin user logged in") }
    }
));
```

---

## Configuration

```csharp
var agent = new AgentBuilder()
    .WithFrontendTools(config =>
    {
        config.InvokeTimeout = TimeSpan.FromSeconds(30);
        config.DisconnectionStrategy = FrontendDisconnectionStrategy.FallbackMessage;
        config.MaxRetries = 3;
        config.FallbackMessageTemplate = "Frontend disconnected. Tool '{0}' unavailable.";
        config.ValidateSchemaOnRegistration = true;
    })
    .Build();
```

### Disconnection Strategies

| Strategy | Behavior |
|----------|----------|
| `FailFast` | Throw exception immediately |
| `RetryWithBackoff` | Retry up to MaxRetries times |
| `FallbackMessage` | Return error message to agent (default) |

---

## Frontend Skills

Group tools into workflows with dual-context instructions:

```csharp
new FrontendPluginDefinition(
    Name: "Checkout",
    Tools: new[] { validateCart, processPayment, confirmOrder },
    Skills: new[]
    {
        new FrontendSkillDefinition(
            Name: "Complete Checkout",
            Description: "Process a customer's checkout",
            // Auto-generated: "Complete Checkout skill activated. Available functions: ValidateCart, ProcessPayment, ConfirmOrder"
            FunctionResult: null,  // Auto-generated message is sufficient
            SystemPrompt: @"
                CHECKOUT WORKFLOW:
                1. Validate the cart contents
                2. Process payment
                3. Confirm order with customer
                4. Show confirmation message",
            References: new[]
            {
                new FrontendSkillReference("ValidateCart"),
                new FrontendSkillReference("ProcessPayment"),
                new FrontendSkillReference("ConfirmOrder")
            }
        )
    }
)
```

---

## State Persistence

Frontend state persists across message turns by default:

```csharp
// Turn 1: Register plugins
var runInput1 = new AgentRunInput { FrontendPlugins = plugins };
await agent.RunAsync("Hello", thread, runInput1);

// Turn 2: Plugins still registered (state persists)
await agent.RunAsync("Use the IDE tools", thread);

// Turn 3: Reset state
var runInput3 = new AgentRunInput { ResetFrontendState = true };
await agent.RunAsync("Start fresh", thread, runInput3);
```

---

## Best Practices

1. **Use collapsing** for plugins with many tools to reduce context clutter.

2. **Provide clear descriptions** so the agent knows when to use each tool.

3. **Handle errors gracefully** - always send a response, even on failure.

4. **Use RequiresPermission** for tools that modify user data.

5. **Keep tools focused** - one action per tool.

```csharp
// Good: Focused tools with clear purposes
new FrontendToolDefinition(
    Name: "OpenFile",
    Description: "Open a file in the editor at an optional line number",
    RequiresPermission: false,
    ParametersSchema: ...
)

new FrontendToolDefinition(
    Name: "DeleteFile",
    Description: "Permanently delete a file",
    RequiresPermission: true,  // Destructive action
    ParametersSchema: ...
)
```

---

## Troubleshooting

| Issue | Cause | Fix |
|-------|-------|-----|
| Tool not appearing | Plugin collapsed | Set `StartCollapsed: false` or pre-expand |
| Timeout error | Client not responding | Increase `InvokeTimeout` |
| Schema validation error | Invalid JSON Schema | Check schema syntax |
| Response not received | RequestId mismatch | Ensure RequestId matches |
