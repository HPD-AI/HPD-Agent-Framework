# Middleware Lifecycle

Complete reference of all available middleware hooks and the context properties available at each stage.

## Execution Flow

```
User Message
    ↓
BeforeMessageTurnAsync (registered order)
    ↓
[LOOP] BeforeIterationAsync (registered order)
    ↓
ExecuteLLMCallAsync (onion architecture - last registered is outermost)
    ↓
LLM Response
    ↓
BeforeToolExecutionAsync (registered order)
    ↓
BeforeParallelBatchAsync (if parallel, registered order, ONCE per batch)
    ↓
[LOOP] BeforeFunctionAsync (registered order, once per function)
    ↓
ExecuteFunctionAsync (onion architecture - first registered is outermost)
    ↓
Function Result
    ↓
AfterFunctionAsync (reverse order)
    ↓
AfterIterationAsync (reverse order)
    ↓
AfterMessageTurnAsync (reverse order)
    ↓
Final Response
```

## Execution Order Rules

- **Before* hooks** - Run in registration order (first registered = first executed)
- **After* hooks** - Run in reverse registration order (last registered = first executed, like stack unwinding)
- **Execute* hooks** - Build an onion architecture

### Onion Architecture Example

When you register middleware like this:

```csharp
.WithMiddleware(new LoggingMiddleware())      // First registered
.WithMiddleware(new CachingMiddleware())      // Second registered
.WithMiddleware(new RetryMiddleware())        // Third registered
```

The execution flows like this:

```
RetryMiddleware.ExecuteFunction()
    ↓ calls next()
CachingMiddleware.ExecuteFunction()
    ↓ calls next()
LoggingMiddleware.ExecuteFunction()
    ↓ calls next()
Actual Function Call
```

The **last registered middleware is the outermost layer**, wrapping everything else.

## Message Turn Level

Called once per user message.

### BeforeMessageTurnAsync

```csharp
public Task BeforeMessageTurnAsync(
    AgentMiddlewareContext context,
    CancellationToken cancellationToken)
```

**When:** Before processing a user message

**Available Properties:**
- `AgentName` - Name of the agent
- `ConversationId` - Session/conversation ID
- `UserMessage` - The user's message
- `ConversationHistory` - Prior messages in the conversation
- `State` - Current agent loop state (immutable)

**Use Cases:**
- RAG injection - Query a knowledge base and inject results into context
- Memory retrieval - Load relevant memories from previous conversations
- Context augmentation - Add system context (date, user info, etc.)
- Message validation - Check for policy violations early

**Example:**

```csharp
public Task BeforeMessageTurnAsync(
    AgentMiddlewareContext context,
    CancellationToken cancellationToken)
{
    // Retrieve relevant memories
    var memories = await _memoryStore.GetRelevant(context.UserMessage);
    
    // Inject as system message
    context.Messages.Insert(0, new ChatMessage(
        ChatRole.User,
        $"Memory context:\n{string.Join("\n", memories)}"
    ));
    
    return Task.CompletedTask;
}
```

### AfterMessageTurnAsync

```csharp
public Task AfterMessageTurnAsync(
    AgentMiddlewareContext context,
    CancellationToken cancellationToken)
```

**When:** After message turn completes (all iterations done)

**Always Runs:** Even if earlier operations failed (for cleanup/logging)

**Available Properties:**
- All properties from `BeforeMessageTurnAsync`, plus:
- `FinalResponse` - The assistant's final response
- `TurnFunctionCalls` - All functions called during this turn

**Use Cases:**
- Memory extraction - Store key information from this turn
- Analytics - Analyze agent behavior, cost, latency
- Persistence - Save results to database
- Feedback collection - Send turn results for monitoring

**Example:**

```csharp
public Task AfterMessageTurnAsync(
    AgentMiddlewareContext context,
    CancellationToken cancellationToken)
{
    // Extract and store key information
    var memory = new ConversationMemory
    {
        UserMessage = context.UserMessage,
        AgentResponse = context.FinalResponse,
        FunctionsCalled = context.TurnFunctionCalls.Select(f => f.Name).ToList(),
        Timestamp = DateTime.UtcNow
    };
    
    return _memoryStore.SaveAsync(memory, cancellationToken);
}
```

## Iteration Level

Called once per LLM call within a turn (loops if agent re-thinks).

### BeforeIterationAsync

```csharp
public Task BeforeIterationAsync(
    AgentMiddlewareContext context,
    CancellationToken cancellationToken)
```

**When:** Before each LLM call

**Available Properties:**
- All prior properties, plus:
- `Iteration` - Which iteration this is (0-based, 0 = first LLM call)
- `Messages` - Messages to send to LLM (mutable!)
- `Options` - Chat options/configuration (mutable!)
- `IsFirstIteration` - True if this is the first LLM call in the turn

**Modify Messages:** You can add, remove, or modify messages before the LLM sees them

**Skip LLM Call:** Set `context.SkipLLMCall = true` to prevent the LLM call. Remaining Before hooks still run.

**Use Cases:**
- History reduction - Summarize old messages to save tokens
- Dynamic instructions - Inject iteration-specific instructions
- Prompt optimization - Rewrite messages for clarity
- Caching check - If you have a cached response, skip the LLM (use `ExecuteLLMCallAsync` instead)

**Example:**

```csharp
public Task BeforeIterationAsync(
    AgentMiddlewareContext context,
    CancellationToken cancellationToken)
{
    // On retry (iteration > 0), add error recovery instruction
    if (context.Iteration > 0)
    {
        var instruction = "The previous approach didn't work. Try a different tool or approach.";
        context.Messages.Insert(0, new ChatMessage(ChatRole.System, instruction));
    }
    
    return Task.CompletedTask;
}
```

### ExecuteLLMCallAsync

```csharp
public IAsyncEnumerable<ChatResponseUpdate> ExecuteLLMCallAsync(
    AgentMiddlewareContext context,
    Func<IAsyncEnumerable<ChatResponseUpdate>> next,
    CancellationToken cancellationToken)
{
    return next(); // Default: pass through
}
```

**When:** Wraps the actual LLM call (advanced hook)

**Advanced:** This hook gives complete control over the LLM call, including skipping it entirely.

**Never Call:** Don't call `next()` more than once per middleware instance.

**Always Yield:** Every update from `next()` must be yielded to preserve streaming.

**Use Cases:**
- **Caching** - Return cached response without calling LLM
- **Retry logic** - Catch exceptions and retry with backoff
- **Token counting** - Count tokens as they stream
- **Response transformation** - Modify streamed updates
- **Rate limiting** - Add delays before calling LLM

**Example - Caching:**

```csharp
public async IAsyncEnumerable<ChatResponseUpdate> ExecuteLLMCallAsync(
    AgentMiddlewareContext context,
    Func<IAsyncEnumerable<ChatResponseUpdate>> next,
    [EnumeratorCancellation] CancellationToken cancellationToken)
{
    var cacheKey = ComputeKey(context.Messages);
    
    // Cache hit - return without LLM call
    if (_cache.TryGet(cacheKey, out var cached))
    {
        yield return cached;
        yield break;
    }
    
    // Cache miss - call LLM and cache result
    var response = new List<ChatResponseUpdate>();
    
    await foreach (var update in next().WithCancellation(cancellationToken))
    {
        response.Add(update);
        yield return update; // Stream it to consumer
    }
    
    // Cache the result for next time
    _cache.Set(cacheKey, response);
}
```

**Example - Retry with Backoff:**

```csharp
public async IAsyncEnumerable<ChatResponseUpdate> ExecuteLLMCallAsync(
    AgentMiddlewareContext context,
    Func<IAsyncEnumerable<ChatResponseUpdate>> next,
    [EnumeratorCancellation] CancellationToken cancellationToken)
{
    for (int attempt = 0; attempt < 3; attempt++)
    {
        Exception? error = null;
        
        try
        {
            await foreach (var update in next().WithCancellation(cancellationToken))
            {
                yield return update;
            }
            
            return; // Success!
        }
        catch (HttpRequestException ex) when (attempt < 2)
        {
            error = ex;
            await Task.Delay(TimeSpan.FromSeconds(Math.Pow(2, attempt)), cancellationToken);
        }
    }
    
    throw new InvalidOperationException("LLM call failed after 3 retries");
}
```

### BeforeToolExecutionAsync

```csharp
public Task BeforeToolExecutionAsync(
    AgentMiddlewareContext context,
    CancellationToken cancellationToken)
```

**When:** After LLM returns but BEFORE any tools execute

**Available Properties:**
- All prior properties, plus:
- `Response` - The LLM's response
- `ToolCalls` - List of function calls the LLM requested

**Skip All Tools:** Set `context.SkipToolExecution = true` to prevent all tools from running.

**Use Cases:**
- Circuit breaker - Detect repeated calls and stop
- Batch validation - Check if all requested tools are allowed
- Pre-execution guards - Validate that tools can run (permissions, resources, etc.)
- Cost estimation - Calculate cost of executing all tools

**Example:**

```csharp
public Task BeforeToolExecutionAsync(
    AgentMiddlewareContext context,
    CancellationToken cancellationToken)
{
    // Circuit breaker: if same tool called 3x in a row, block it
    if (context.ToolCalls.Count > 0)
    {
        var cbState = context.State.MiddlewareState.CircuitBreaker ?? new();
        
        foreach (var toolCall in context.ToolCalls)
        {
            var signature = ComputeSignature(toolCall);
            
            if (cbState.GetCount(toolCall.Name, signature) >= 3)
            {
                context.SkipToolExecution = true;
                context.Emit(new TextDeltaEvent 
                { 
                    Text = $"⚠️ Stopping repeated calls to {toolCall.Name}" 
                });
            }
        }
    }
    
    return Task.CompletedTask;
}
```

### AfterIterationAsync

```csharp
public Task AfterIterationAsync(
    AgentMiddlewareContext context,
    CancellationToken cancellationToken)
```

**When:** After all tools complete for this iteration

**Always Runs:** Even if tool execution failed

**Available Properties:**
- All prior properties, plus:
- `ToolResults` - Results from each tool execution

**Use Cases:**
- Error tracking - Count and categorize errors
- Result validation - Ensure tools returned valid data
- State updates - Update middleware state for next iteration
- Cleanup - Release resources

**Example:**

```csharp
public Task AfterIterationAsync(
    AgentMiddlewareContext context,
    CancellationToken cancellationToken)
{
    // Track errors
    var errorState = context.State.MiddlewareState.ErrorTracking ?? new();
    
    foreach (var result in context.ToolResults)
    {
        if (result.Exception != null)
        {
            errorState = errorState with 
            { 
                ErrorCount = errorState.ErrorCount + 1 
            };
        }
    }
    
    context.UpdateState(s => s with 
    {
        MiddlewareState = s.MiddlewareState.WithErrorTracking(errorState)
    });
    
    return Task.CompletedTask;
}
```

## Function Level

Called for each individual function execution.

### BeforeParallelBatchAsync

```csharp
public Task BeforeParallelBatchAsync(
    AgentMiddlewareContext context,
    CancellationToken cancellationToken)
```

**When:** Before multiple functions execute in parallel (once per batch, not per function)

**Not Called:** For single function execution

**Available Properties:**
- All prior properties, plus:
- `ParallelFunctions` - List of all functions about to execute in parallel

**Use Cases:**
- Batch permissions - Request approval for all functions at once (single dialog)
- Resource reservation - Reserve resources needed for all functions
- Batch validation - Validate that all functions can run together
- Optimization - Pre-fetch data used by multiple functions

**Important:** Use `context.UpdateState()` to store batch decisions for `BeforeFunctionAsync` to check

**Example:**

```csharp
public async Task BeforeParallelBatchAsync(
    AgentMiddlewareContext context,
    CancellationToken cancellationToken)
{
    // Request batch approval
    var functions = context.ParallelFunctions
        .Select(f => f.Name ?? "_unknown")
        .ToList();
    
    var approved = await _permissionSystem.RequestBatchApproval(functions, cancellationToken);
    
    // Store in state for BeforeFunctionAsync to check
    var batchState = new BatchPermissionState { Approvals = approved };
    context.UpdateState(s => s with 
    {
        MiddlewareState = s.MiddlewareState.WithBatchPermissions(batchState)
    });
}
```

### BeforeFunctionAsync

```csharp
public Task BeforeFunctionAsync(
    AgentMiddlewareContext context,
    CancellationToken cancellationToken)
```

**When:** Before each function executes (both sequential and parallel)

**Called For:** Every function, regardless of execution mode

**Available Properties:**
- All prior properties, plus:
- `Function` - The AIFunction being called
- `FunctionCallId` - Unique ID for this specific invocation
- `FunctionArguments` - The parsed function arguments

**Block Function:** Set `context.BlockFunctionExecution = true` to prevent THIS function from running

**Provide Result:** Set `context.FunctionResult` when blocking to provide a result without execution

**Use Cases:**
- Permission checking - Ask user to approve this specific function
- Argument validation - Check function arguments for safety/validity
- Per-function guards - Enforce per-function policies
- Logging - Log which function is about to execute

**Example:**

```csharp
public async Task BeforeFunctionAsync(
    AgentMiddlewareContext context,
    CancellationToken cancellationToken)
{
    // Check if this specific function is allowed
    if (!_allowedFunctions.Contains(context.Function?.Name ?? "_unknown"))
    {
        context.BlockFunctionExecution = true;
        context.FunctionResult = "This function is not allowed";
        return;
    }
    
    // For batch approvals, check the batch state
    var batchState = context.State.MiddlewareState.BatchPermissions;
    if (batchState?.Approvals != null && 
        !batchState.Approvals.Contains(context.Function?.Name ?? "_unknown"))
    {
        context.BlockFunctionExecution = true;
        context.FunctionResult = "User did not approve this function";
    }
}
```

### ExecuteFunctionAsync

```csharp
public async ValueTask<object?> ExecuteFunctionAsync(
    AgentMiddlewareContext context,
    Func<ValueTask<object?>> next,
    CancellationToken cancellationToken)
{
    return await next(); // Default: pass through
}
```

**When:** Wraps the actual function call (advanced hook)

**Advanced:** Complete control over function execution

**Use Cases:**
- **Retry logic** - Retry failed functions with backoff
- **Timeouts** - Enforce timeout on function execution
- **Caching** - Cache function results
- **Transformation** - Transform function arguments or results
- **Monitoring** - Track timing and success/failure

**Example - Retry with Backoff:**

```csharp
public async ValueTask<object?> ExecuteFunctionAsync(
    AgentMiddlewareContext context,
    Func<ValueTask<object?>> next,
    CancellationToken cancellationToken)
{
    for (int attempt = 0; attempt < 3; attempt++)
    {
        try
        {
            return await next();
        }
        catch (HttpRequestException) when (attempt < 2)
        {
            await Task.Delay(
                TimeSpan.FromSeconds(Math.Pow(2, attempt)), 
                cancellationToken
            );
        }
    }
    
    throw new InvalidOperationException("Function failed after 3 retries");
}
```

**Example - Timeout:**

```csharp
public async ValueTask<object?> ExecuteFunctionAsync(
    AgentMiddlewareContext context,
    Func<ValueTask<object?>> next,
    CancellationToken cancellationToken)
{
    using var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
    cts.CancelAfter(TimeSpan.FromSeconds(30)); // 30 second timeout
    
    try
    {
        return await next();
    }
    catch (OperationCanceledException)
    {
        throw new TimeoutException(
            $"Function {context.Function?.Name} timed out after 30 seconds"
        );
    }
}
```

### AfterFunctionAsync

```csharp
public Task AfterFunctionAsync(
    AgentMiddlewareContext context,
    CancellationToken cancellationToken)
```

**When:** After function completes

**Always Runs:** Even if function failed

**Available Properties:**
- All prior properties, plus:
- `FunctionResult` - The result returned by the function (or custom result if blocked)
- `FunctionException` - Exception thrown by the function (null if successful)

**Use Cases:**
- Logging - Log function execution with result/error
- Result transformation - Transform the result
- Error handling - Decide whether to retry or propagate error
- Analytics - Track function execution time, success rate

**Example:**

```csharp
public Task AfterFunctionAsync(
    AgentMiddlewareContext context,
    CancellationToken cancellationToken)
{
    var duration = DateTime.UtcNow - context.ExecutionStartTime;
    
    if (context.FunctionException != null)
    {
        _logger.LogError(
            "Function {Function} failed after {Duration}ms: {Error}",
            context.Function?.Name,
            duration.TotalMilliseconds,
            context.FunctionException.Message
        );
    }
    else
    {
        _logger.LogInformation(
            "Function {Function} succeeded in {Duration}ms",
            context.Function?.Name,
            duration.TotalMilliseconds
        );
    }
    
    return Task.CompletedTask;
}
```

## State Management

Middleware can store and retrieve typed state that persists across turns and survives checkpoints.

### Reading State

```csharp
// Read middleware state (type-safe)
var myState = context.State.MiddlewareState.MyCustomState ?? new();

// State is immutable - create new instance with changes
var updated = myState with { Count = myState.Count + 1 };
```

### Updating State

```csharp
// Schedule state update (applied after middleware chain)
context.UpdateState(s => s with 
{
    MiddlewareState = s.MiddlewareState.WithMyCustomState(updated)
});
```

### Important Notes

- State updates are scheduled, not applied immediately
- All updates from the middleware chain are applied together after the chain completes
- State is immutable and thread-safe
- Use state instead of instance fields to support concurrent calls

## Events & Bidirectional Communication

Middleware can emit events and wait for responses.

### Emit One-Way Event

```csharp
context.Emit(new TextDeltaEvent { Text = "Processing..." });
context.Emit(new CustomEvent { ... });
```

### Request/Response Pattern

```csharp
// Emit request event
var request = new PermissionRequestEvent 
{ 
    FunctionName = context.Function?.Name,
    RequestId = Guid.NewGuid().ToString()
};

context.Emit(request);

// Wait for response
var response = await context.WaitForResponseAsync<PermissionResponse>(
    request.RequestId,
    cancellationToken
);

if (response.Approved == false)
{
    context.BlockFunctionExecution = true;
}
```

## Context Property Reference

### Always Available

| Property | Type | Description |
|----------|------|-------------|
| `AgentName` | `string` | Name of the executing agent |
| `ConversationId` | `string?` | Session/conversation ID |
| `CancellationToken` | `CancellationToken` | Cancellation token for the operation |
| `State` | `AgentLoopState` | Current agent loop state (immutable) |

### Message Turn Level

| Property | Type | Available | Mutable |
|----------|------|-----------|---------|
| `UserMessage` | `string` | BeforeMessageTurn+ | N/A |
| `ConversationHistory` | `IReadOnlyList<ChatMessage>` | BeforeMessageTurn+ | N/A |
| `FinalResponse` | `string` | AfterMessageTurn | N/A |
| `TurnFunctionCalls` | `IReadOnlyList<...>` | AfterMessageTurn | N/A |

### Iteration Level

| Property | Type | Available | Mutable |
|----------|------|-----------|---------|
| `Iteration` | `int` | BeforeIteration+ | N/A |
| `IsFirstIteration` | `bool` | BeforeIteration+ | N/A |
| `Messages` | `IList<ChatMessage>` | BeforeIteration+ | ✓ Yes |
| `Options` | `ChatOptions?` | BeforeIteration+ | ✓ Yes |
| `Response` | `string?` | BeforeToolExecution+ | N/A |
| `ToolCalls` | `IReadOnlyList<...>` | BeforeToolExecution+ | N/A |
| `ToolResults` | `IReadOnlyList<...>` | AfterIteration+ | N/A |

### Function Level

| Property | Type | Available | Mutable |
|----------|------|-----------|---------|
| `ParallelFunctions` | `IReadOnlyList<AIFunction>` | BeforeParallelBatch | N/A |
| `Function` | `AIFunction?` | BeforeFunction+ | N/A |
| `FunctionCallId` | `string` | BeforeFunction+ | N/A |
| `FunctionArguments` | `object?` | BeforeFunction+ | N/A |
| `FunctionResult` | `object?` | AfterFunction | ✓ Yes (when blocking) |
| `FunctionException` | `Exception?` | AfterFunction | N/A |

## Next Steps

- See [05.2 Middleware State](./05.2%20Middleware%20State.md) for state management
- See [05.3 Middleware Events](./05.3%20Middleware%20Events.md) for events and bidirectional communication
- See [05.4 Built-in Middleware](./05.4%20Built-in%20Middleware.md) for ready-to-use middleware
- See [05.5 Custom Middleware](./05.5%20Custom%20Middleware.md) for building your own
- See [../Getting%20Started/05%20Middleware.md](../Getting%20Started/05%20Middleware.md) for overview
