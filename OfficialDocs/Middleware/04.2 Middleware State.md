# Middleware State

Manage typed, immutable state across middleware hooks using source-generated properties.


## Quick Example

**1. Define your state record:**

```csharp
[MiddlewareState]
public sealed record MyCounterState
{
    public int Count { get; init; } = 0;
}
```

**2. Read and update in middleware:**

```csharp
public class CounterMiddleware : IAgentMiddleware
{
    public Task BeforeIterationAsync(BeforeIterationContext context, CancellationToken ct)
    {
        // Read (auto-generated property)
        var state = context.State.MiddlewareState.MyCounter ?? new();

        // Update immutably
        context.UpdateState(s => s with
        {
            MiddlewareState = s.MiddlewareState.WithMyCounter(state with
            {
                Count = state.Count + 1
            })
        });

        return Task.CompletedTask;
    }
}
```

**3. Source generator creates:**

```csharp
public sealed partial class MiddlewareState
{
    public MyCounterState? MyCounter { get; } // Auto-generated getter
    public MiddlewareState WithMyCounter(MyCounterState? value) { } // Auto-generated setter
}
```

## Creating Middleware State

### Step 1: Define State Record

```csharp
using HPD.Agent;

[MiddlewareState(Version = 1)]
public sealed record ErrorTrackingState
{
    public int ConsecutiveFailures { get; init; } = 0;
    public DateTime? LastErrorTime { get; init; }

    // Helper methods (optional)
    public ErrorTrackingState IncrementFailures() =>
        this with
        {
            ConsecutiveFailures = ConsecutiveFailures + 1,
            LastErrorTime = DateTime.UtcNow
        };

    public ErrorTrackingState ResetFailures() =>
        this with { ConsecutiveFailures = 0, LastErrorTime = null };
}
```

### Requirements

-   Must be a **`record`** (compile error if not)
-   Should be **`sealed`** for performance (compiler warning if not)
-   All properties must be **JSON-serializable** (runtime error during checkpoint save/restore if not)
-   Use **`{ get; init; }`** for immutability

## Reading State

State is available via `context.State.MiddlewareState`:

```csharp
public Task BeforeIterationAsync(BeforeIterationContext context, CancellationToken ct)
{
    // Read with null-coalescing (state may be null on first use)
    var errorState = context.State.MiddlewareState.ErrorTracking ?? new();

    if (errorState.ConsecutiveFailures >= 3)
    {
        // Take action
    }

    return Task.CompletedTask;
}
```

**Always provide default:** State is `null` until first update.

## Updating State

### Immediate Updates

Updates are **applied immediately**:

```csharp
public Task BeforeIterationAsync(BeforeIterationContext context, CancellationToken ct)
{
    var state = context.State.MiddlewareState.MyCounter ?? new();

    // Update
    context.UpdateState(s => s with
    {
        MiddlewareState = s.MiddlewareState.WithMyCounter(state with { Count = state.Count + 1 })
    });

    //   Next middleware sees updated state immediately!
    var updated = context.State.MiddlewareState.MyCounter;
    Console.WriteLine(updated.Count); // Shows incremented value
}
```

**Updates are immediate** - visible to all subsequent middleware.

### Immutable Pattern

Always use `with` expressions:

```csharp
//   CORRECT: Immutable update
context.UpdateState(s => s with
{
    MiddlewareState = s.MiddlewareState.WithMyState(currentState with
    {
        Count = currentState.Count + 1
    })
});

//    WRONG: Mutation
currentState.Count++; // Compile error - init-only property
```

### Nested State Updates

```csharp
public Task AfterIterationAsync(AfterIterationContext context, CancellationToken ct)
{
    var errors = context.ToolResults.Count(r => r.Exception != null);
    var errorState = context.State.MiddlewareState.ErrorTracking ?? new();

    if (errors > 0)
    {
        // Update error state
        var newErrorState = errorState.IncrementFailures();

        context.UpdateState(s => s with
        {
            MiddlewareState = s.MiddlewareState.WithErrorTracking(newErrorState),
            // Can update multiple fields
            IsTerminated = newErrorState.ConsecutiveFailures >= 3,
            TerminationReason = "Too many errors"
        });
    }
    else
    {
        // Reset on success
        context.UpdateState(s => s with
        {
            MiddlewareState = s.MiddlewareState.WithErrorTracking(errorState.ResetFailures())
        });
    }

    return Task.CompletedTask;
}
```

## State Versioning

Version tracks breaking schema changes:

```csharp
[MiddlewareState(Version = 2)] // Bumped from 1 → 2
public sealed record MyState
{
    public int Count { get; init; } // Was string in v1
}
```

### When to Bump Version

**Increment version for:**
-  Removing properties
-  Renaming properties
-  Changing property types
-  Changing collection types (List → ImmutableList)

**No version bump needed for:**
-   Adding new properties with defaults
-   Adding helper methods
-   Updating documentation

## Complex State Example

```csharp
[MiddlewareState(Version = 1)]
public sealed record CircuitBreakerState
{
    public Dictionary<string, int> CallCounts { get; init; } = new();
    public Dictionary<string, string> LastSignatures { get; init; } = new();

    public int GetCount(string toolName, string signature)
    {
        if (!LastSignatures.TryGetValue(toolName, out var lastSig))
            return 0;

        return lastSig == signature
            ? CallCounts.GetValueOrDefault(toolName, 0)
            : 0;
    }

    public CircuitBreakerState IncrementCount(string toolName, string signature)
    {
        var lastSig = LastSignatures.GetValueOrDefault(toolName);
        var count = lastSig == signature
            ? CallCounts.GetValueOrDefault(toolName, 0) + 1
            : 1;

        return this with
        {
            CallCounts = new Dictionary<string, int>(CallCounts)
            {
                [toolName] = count
            },
            LastSignatures = new Dictionary<string, string>(LastSignatures)
            {
                [toolName] = signature
            }
        };
    }

    public CircuitBreakerState Reset(string toolName)
    {
        var newCounts = new Dictionary<string, int>(CallCounts);
        newCounts.Remove(toolName);

        var newSigs = new Dictionary<string, string>(LastSignatures);
        newSigs.Remove(toolName);

        return this with
        {
            CallCounts = newCounts,
            LastSignatures = newSigs
        };
    }
}
```

## State Sharing Between Middleware

State is **global** - all middleware can read/write:

```csharp
// Middleware A writes
public class ErrorTrackerMiddleware : IAgentMiddleware
{
    public Task AfterIterationAsync(AfterIterationContext context, CancellationToken ct)
    {
        var state = context.State.MiddlewareState.ErrorTracking ?? new();
        context.UpdateState(s => s with
        {
            MiddlewareState = s.MiddlewareState.WithErrorTracking(
                state.IncrementFailures()
            )
        });
        return Task.CompletedTask;
    }
}

// Middleware B reads
public class CircuitBreakerMiddleware : IAgentMiddleware
{
    public Task BeforeIterationAsync(BeforeIterationContext context, CancellationToken ct)
    {
        //   Can read ErrorTracking state from ErrorTrackerMiddleware
        var errorState = context.State.MiddlewareState.ErrorTracking ?? new();

        if (errorState.ConsecutiveFailures >= 3)
        {
            context.UpdateState(s => s with
            {
                IsTerminated = true,
                TerminationReason = "Circuit breaker"
            });
        }

        return Task.CompletedTask;
    }
}
```

## State Persistence

State **persists across:**
-   Iterations within a turn
-   Multiple turns in a session
-   Agent restarts (if using `AgentSession` with checkpoint storage)

```csharp
// Turn 1
await agent.RunAsync("What's 2+2?"); // State.Count = 1

// Turn 2 (same session)
await agent.RunAsync("And 3+3?"); // State.Count = 2 (persisted!)
```

## Thread Safety

State is **immutable** - safe for concurrent `RunAsync()` calls:

```csharp
//   SAFE: Two parallel calls, independent state
var task1 = agent.RunAsync("First query");
var task2 = agent.RunAsync("Second query");
await Task.WhenAll(task1, task2);
```

**Never use instance fields** for state:

```csharp
public class BadMiddleware : IAgentMiddleware
{
    //    WRONG: Not thread-safe!
    private int _count = 0;

    public Task BeforeIterationAsync(BeforeIterationContext context, CancellationToken ct)
    {
        _count++; // Race condition with parallel RunAsync calls
        return Task.CompletedTask;
    }
}
```

```csharp
public class GoodMiddleware : IAgentMiddleware
{
    //   CORRECT: Use context state
    public Task BeforeIterationAsync(BeforeIterationContext context, CancellationToken ct)
    {
        var state = context.State.MiddlewareState.MyCounter ?? new();
        context.UpdateState(s => s with
        {
            MiddlewareState = s.MiddlewareState.WithMyCounter(state with { Count = state.Count + 1 })
        });
        return Task.CompletedTask;
    }
}
```

## Common Patterns

### Pattern 1: Error Counting

```csharp
[MiddlewareState]
public sealed record ErrorCountState
{
    public int TotalErrors { get; init; }
    public int ConsecutiveErrors { get; init; }
}

public Task OnErrorAsync(ErrorContext context, CancellationToken ct)
{
    var state = context.State.MiddlewareState.ErrorCount ?? new();

    context.UpdateState(s => s with
    {
        MiddlewareState = s.MiddlewareState.WithErrorCount(state with
        {
            TotalErrors = state.TotalErrors + 1,
            ConsecutiveErrors = state.ConsecutiveErrors + 1
        })
    });

    return Task.CompletedTask;
}
```

### Pattern 2: Rate Limiting

```csharp
[MiddlewareState]
public sealed record RateLimitState
{
    public DateTime? LastCallTime { get; init; }
    public int CallsInWindow { get; init; }
}

public async Task BeforeIterationAsync(BeforeIterationContext context, CancellationToken ct)
{
    var state = context.State.MiddlewareState.RateLimit ?? new();
    var now = DateTime.UtcNow;

    if (state.LastCallTime.HasValue &&
        (now - state.LastCallTime.Value) < TimeSpan.FromMinutes(1))
    {
        if (state.CallsInWindow >= 10)
        {
            await Task.Delay(TimeSpan.FromSeconds(60), ct);
        }

        context.UpdateState(s => s with
        {
            MiddlewareState = s.MiddlewareState.WithRateLimit(state with
            {
                CallsInWindow = state.CallsInWindow + 1
            })
        });
    }
    else
    {
        context.UpdateState(s => s with
        {
            MiddlewareState = s.MiddlewareState.WithRateLimit(new RateLimitState
            {
                LastCallTime = now,
                CallsInWindow = 1
            })
        });
    }
}
```

### Pattern 3: Batch State

```csharp
[MiddlewareState]
public sealed record BatchApprovalState
{
    public HashSet<string> ApprovedFunctions { get; init; } = new();
}

public async Task BeforeParallelBatchAsync(BeforeParallelBatchContext context, CancellationToken ct)
{
    var functions = context.ParallelFunctions.Select(f => f.Name ?? "_unknown").ToList();
    var approved = await RequestApproval(functions, ct);

    context.UpdateState(s => s with
    {
        MiddlewareState = s.MiddlewareState.WithBatchApproval(new BatchApprovalState
        {
            ApprovedFunctions = approved.ToHashSet()
        })
    });
}

public Task BeforeFunctionAsync(BeforeFunctionContext context, CancellationToken ct)
{
    var state = context.State.MiddlewareState.BatchApproval;

    if (state != null && !state.ApprovedFunctions.Contains(context.Function.Name))
    {
        context.BlockExecution = true;
        context.OverrideResult = "Not approved";
    }

    return Task.CompletedTask;
}
```

## Next Steps

- [05.1 Middleware Lifecycle](./05.1%20Middleware%20Lifecycle.md) - Complete hook reference
- [05.3 Middleware Events](./05.3%20Middleware%20Events.md) - Emit events and wait for responses
- [05.4 Built-in Middleware](./05.4%20Built-in%20Middleware.md) - See state usage in real middleware
- [05.5 Custom Middleware](./05.5%20Custom%20Middleware.md) - Build your own with state
