using HPD.Agent.Hosting.Lifecycle;

namespace HPD.Agent.Adapters.Session;

/// <summary>
/// Resolves an inbound platform message to an HPD <c>sessionId</c> + <c>branchId</c>.
/// Operates in-process against <see cref="AgentSessionManager"/> — no external store, no HTTP.
/// </summary>
/// <remarks>
/// <para>
/// <see cref="ResolveAsync"/> searches the session store by <c>metadata["platformKey"]</c>.
/// On a miss it delegates to <see cref="AgentSessionManager.CreateSessionAsync"/> — the same
/// method that creates the session, the default "main" branch, and persists both atomically.
/// </para>
/// <para>
/// The mapper never bypasses <see cref="AgentSessionManager"/>. All session creation goes
/// through the manager so that concurrency locks, idle eviction, and agent caching remain
/// consistent.
/// </para>
/// <para>
/// <b>Performance note (open question §5):</b> <see cref="ResolveAsync"/> currently does
/// <c>ListSessionIdsAsync</c> + load-each — O(n) over all sessions. Acceptable for low-volume
/// deployments but degrades at scale. A future iteration can add an in-memory
/// <c>ConcurrentDictionary</c> cache or a secondary index in <c>ISessionStore</c>.
/// </para>
/// </remarks>
public sealed class PlatformSessionMapper
{
    private const string PlatformKeyMetadataField = "platformKey";

    private readonly AgentSessionManager _manager;

    /// <summary>
    /// Initialises the mapper with the session manager for the target agent.
    /// </summary>
    public PlatformSessionMapper(AgentSessionManager manager)
    {
        _manager = manager ?? throw new ArgumentNullException(nameof(manager));
    }

    /// <summary>
    /// Finds the existing session for <paramref name="platformKey"/>, or creates a new one.
    /// </summary>
    /// <param name="platformKey">
    /// Opaque platform-specific key (e.g. <c>"slack:C123:1234567890.000100"</c>).
    /// Generated by the adapter's <c>[ThreadId]</c> record.
    /// </param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>
    /// The <c>sessionId</c> and <c>branchId</c> ("main") for this platform key.
    /// </returns>
    public async Task<(string SessionId, string BranchId)> ResolveAsync(
        string platformKey,
        CancellationToken ct = default)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(platformKey);

        // Search existing sessions for a matching platformKey in metadata
        var sessionIds = await _manager.Store.ListSessionIdsAsync(ct);
        foreach (var sessionId in sessionIds)
        {
            var session = await _manager.Store.LoadSessionAsync(sessionId, ct);
            if (session?.Metadata != null &&
                session.Metadata.TryGetValue(PlatformKeyMetadataField, out var storedKey) &&
                storedKey is string sk && sk == platformKey)
            {
                // Return the first branch (always "main" for adapter-created sessions)
                var branchIds = await _manager.Store.ListBranchIdsAsync(sessionId, ct);
                var branchId  = branchIds.Count > 0 ? branchIds[0] : "main";
                return (sessionId, branchId);
            }
        }

        // No match — create a new session via the manager (atomically creates session + "main" branch)
        var metadata = new Dictionary<string, object>
        {
            [PlatformKeyMetadataField] = platformKey,
        };

        return await _manager.CreateSessionAsync(metadata: metadata, ct: ct);
    }

    /// <summary>
    /// Resets the session for <paramref name="platformKey"/> — deletes the existing session
    /// (if any) and creates a fresh one.
    /// </summary>
    /// <remarks>
    /// Use this when the user explicitly starts a new conversation (e.g. a "reset" slash command).
    /// </remarks>
    public async Task<(string SessionId, string BranchId)> ResetAsync(
        string platformKey,
        CancellationToken ct = default)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(platformKey);

        // Find and delete existing session
        var sessionIds = await _manager.Store.ListSessionIdsAsync(ct);
        foreach (var sessionId in sessionIds)
        {
            var session = await _manager.Store.LoadSessionAsync(sessionId, ct);
            if (session?.Metadata != null &&
                session.Metadata.TryGetValue(PlatformKeyMetadataField, out var storedKey) &&
                storedKey is string sk && sk == platformKey)
            {
                await _manager.Store.DeleteSessionAsync(sessionId, ct);
                _manager.RemoveAgent(sessionId);
                break;
            }
        }

        // Create fresh session
        var metadata = new Dictionary<string, object>
        {
            [PlatformKeyMetadataField] = platformKey,
        };

        return await _manager.CreateSessionAsync(metadata: metadata, ct: ct);
    }
}
