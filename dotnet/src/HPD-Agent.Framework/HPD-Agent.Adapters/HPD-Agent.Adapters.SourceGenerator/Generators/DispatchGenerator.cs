using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace HPD.Agent.Adapters.SourceGenerator.Generators;

/// <summary>
/// Generates {AdapterName}Dispatch.g.cs for each [HpdAdapter] class.
///
/// The generated HandleWebhookAsync method:
///   1. Reads body once
///   2. Verifies HMAC signature (if [HpdWebhookSignature] present)
///   3. Detects content-type (JSON envelope vs form-urlencoded interactive payload)
///   4. Deserialises the outer type discriminator
///   5. Dispatches to the [HpdWebhookHandler] method matching the event type
///   6. Maps known adapter exceptions to HTTP status codes
/// </summary>
internal static class DispatchGenerator
{
    public static void Generate(
        SourceProductionContext context,
        IReadOnlyList<AdapterInfo> adapters)
    {
        foreach (var adapter in adapters)
        {
            var source = BuildSource(adapter);
            context.AddSource($"{adapter.ClassName}Dispatch.g.cs",
                SourceText.From(source, Encoding.UTF8));
        }
    }

    private static string BuildSource(AdapterInfo adapter)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Threading;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine("using Microsoft.AspNetCore.Http;");
        sb.AppendLine("using Microsoft.AspNetCore.Http.Extensions;");
        sb.AppendLine("using HPD.Agent.Adapters;");
        sb.AppendLine("using HPD.Agent.Adapters.Contracts;");
        sb.AppendLine("using HPD.Agent.Adapters.AspNetCore.Verification;");
        sb.AppendLine("using System.Text.Json;");
        sb.AppendLine("using System.Text.Json.Serialization.Metadata;");
        sb.AppendLine();
        sb.AppendLine($"namespace {adapter.Namespace};");
        sb.AppendLine();
        sb.AppendLine($"public partial class {adapter.ClassName}");
        sb.AppendLine("{");
        sb.AppendLine("    /// <summary>Generated webhook dispatch entry point.</summary>");
        sb.AppendLine("    public async Task<IResult> HandleWebhookAsync(HttpContext ctx)");
        sb.AppendLine("    {");
        sb.AppendLine("        var ct = ctx.RequestAborted;");
        sb.AppendLine();

        // ── Read body once ────────────────────────────────────────────────────
        sb.AppendLine("        // Read body once — reused for both signature verification and deserialization");
        sb.AppendLine("        byte[] bodyBytes;");
        sb.AppendLine("        using (var ms = new System.IO.MemoryStream())");
        sb.AppendLine("        {");
        sb.AppendLine("            await ctx.Request.Body.CopyToAsync(ms, ct);");
        sb.AppendLine("            bodyBytes = ms.ToArray();");
        sb.AppendLine("        }");
        sb.AppendLine();

        // ── Signature verification ────────────────────────────────────────────
        if (adapter.Signature is { } sig)
        {
            sb.AppendLine("        // url_verification challenge must respond without signature (Slack sends none)");
            sb.AppendLine("        var _quickType = ExtractEventType(bodyBytes);");
            sb.AppendLine("        if (_quickType != \"url_verification\")");
            sb.AppendLine("        {");
            sb.AppendLine("            // Verify webhook signature");
            sb.AppendLine($"            if (!WebhookSignatureVerifier.Verify(");
            sb.AppendLine($"                HmacFormat.{sig.Format},");
            sb.AppendLine($"                bodyBytes,");
            sb.AppendLine($"                ctx.Request.Headers,");
            sb.AppendLine($"                _config.SigningSecret,");
            sb.AppendLine($"                \"{sig.SignatureHeader}\",");
            sb.AppendLine($"                \"{sig.TimestampHeader}\",");
            sb.AppendLine($"                {sig.WindowSeconds}))");
            sb.AppendLine("            {");
            sb.AppendLine("                return Results.Unauthorized();");
            sb.AppendLine("            }");
            sb.AppendLine("        }");
            sb.AppendLine();
        }

        // ── Exception wrapper + dispatch ──────────────────────────────────────
        sb.AppendLine("        try");
        sb.AppendLine("        {");
        sb.AppendLine("            return await DispatchAsync(ctx, bodyBytes, ct);");
        sb.AppendLine("        }");
        sb.AppendLine("        catch (AdapterAuthenticationException)  { return Results.Unauthorized(); }");
        sb.AppendLine("        catch (AdapterRateLimitException)       { return Results.StatusCode(429); }");
        sb.AppendLine("        catch (AdapterPermissionException)      { return Results.Forbid(); }");
        sb.AppendLine("        catch (AdapterNotFoundException)        { return Results.NotFound(); }");
        sb.AppendLine("    }");
        sb.AppendLine();

        // ── Inner dispatch ────────────────────────────────────────────────────
        sb.AppendLine("    private async Task<IResult> DispatchAsync(");
        sb.AppendLine("        HttpContext ctx, byte[] bodyBytes, CancellationToken ct)");
        sb.AppendLine("    {");
        sb.AppendLine("        var contentType = ctx.Request.ContentType ?? string.Empty;");
        sb.AppendLine();
        sb.AppendLine("        // Form-urlencoded interactive payloads (block_actions, view_submission, etc.)");
        sb.AppendLine("        if (contentType.Contains(\"application/x-www-form-urlencoded\", System.StringComparison.OrdinalIgnoreCase))");
        sb.AppendLine("        {");
        sb.AppendLine("            var form = System.Text.Encoding.UTF8.GetString(bodyBytes);");
        sb.AppendLine("            var payloadJson = System.Web.HttpUtility.ParseQueryString(form)[\"payload\"];");
        sb.AppendLine("            if (payloadJson != null)");
        sb.AppendLine("            {");
        sb.AppendLine("                var interactiveType = ExtractType(System.Text.Encoding.UTF8.GetBytes(payloadJson));");
        sb.AppendLine("                return await DispatchByTypeAsync(ctx, System.Text.Encoding.UTF8.GetBytes(payloadJson), interactiveType, ct);");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        // JSON envelope — extract event type");
        sb.AppendLine("        var eventType = ExtractEventType(bodyBytes);");
        sb.AppendLine("        return await DispatchByTypeAsync(ctx, bodyBytes, eventType, ct);");
        sb.AppendLine("    }");
        sb.AppendLine();

        // ── Type extraction helpers ───────────────────────────────────────────
        sb.AppendLine("    private static string? ExtractType(byte[] bodyBytes)");
        sb.AppendLine("    {");
        sb.AppendLine("        try");
        sb.AppendLine("        {");
        sb.AppendLine("            using var doc = JsonDocument.Parse(bodyBytes);");
        sb.AppendLine("            if (doc.RootElement.TryGetProperty(\"type\", out var t)) return t.GetString();");
        sb.AppendLine("        }");
        sb.AppendLine("        catch { }");
        sb.AppendLine("        return null;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    private static string? ExtractEventType(byte[] bodyBytes)");
        sb.AppendLine("    {");
        sb.AppendLine("        try");
        sb.AppendLine("        {");
        sb.AppendLine("            using var doc = JsonDocument.Parse(bodyBytes);");
        sb.AppendLine("            var root = doc.RootElement;");
        sb.AppendLine("            // For event_callback envelopes, use the inner event.type");
        sb.AppendLine("            if (root.TryGetProperty(\"type\", out var outerType))");
        sb.AppendLine("            {");
        sb.AppendLine("                var outer = outerType.GetString();");
        sb.AppendLine("                if (outer == \"event_callback\" &&");
        sb.AppendLine("                    root.TryGetProperty(\"event\", out var evt) &&");
        sb.AppendLine("                    evt.TryGetProperty(\"type\", out var innerType))");
        sb.AppendLine("                {");
        sb.AppendLine("                    return innerType.GetString();");
        sb.AppendLine("                }");
        sb.AppendLine("                return outer;");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine("        catch { }");
        sb.AppendLine("        return null;");
        sb.AppendLine("    }");
        sb.AppendLine();

        // ── Switch dispatch ───────────────────────────────────────────────────
        sb.AppendLine("    private async Task<IResult> DispatchByTypeAsync(");
        sb.AppendLine("        HttpContext ctx, byte[] bodyBytes, string? eventType, CancellationToken ct)");
        sb.AppendLine("    {");
        sb.AppendLine("        switch (eventType)");
        sb.AppendLine("        {");

        foreach (var handler in adapter.Handlers)
        {
            foreach (var eventType in handler.EventTypes)
            {
                sb.AppendLine($"            case \"{eventType}\":");
            }
            sb.AppendLine("            {");
            sb.AppendLine($"                var payload = JsonSerializer.Deserialize<{handler.PayloadTypeFqn}>(bodyBytes, _jsonOptions);");
            sb.AppendLine($"                if (payload is null) return Results.Ok();");
            sb.AppendLine($"                return await {handler.MethodName}(ctx, payload);");
            sb.AppendLine("            }");
        }

        sb.AppendLine("            default: return Results.Ok(); // unknown event types → ACK and ignore");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    private static readonly JsonSerializerOptions _jsonOptions = new()");
        sb.AppendLine("    {");
        sb.AppendLine("        PropertyNamingPolicy = JsonNamingPolicy.SnakeCaseLower,");
        sb.AppendLine("        DefaultIgnoreCondition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull,");
        sb.AppendLine("    };");
        sb.AppendLine("}");

        return sb.ToString();
    }
}
