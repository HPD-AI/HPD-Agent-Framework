using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace HPDAgent.Graph.SourceGenerator;

/// <summary>
/// Source generator that creates bridge code for handlers marked with [GraphNodeHandler].
/// Generates the implementation of IGraphNodeHandler.ExecuteAsync that calls the clean user method.
/// </summary>
[Generator]
public class SocketBridgeGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        // Register a syntax receiver that will collect candidate classes
        context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxReceiver is not SyntaxReceiver receiver)
            return;

        foreach (var candidateClass in receiver.CandidateClasses)
        {
            var model = context.Compilation.GetSemanticModel(candidateClass.SyntaxTree);
            var classSymbol = model.GetDeclaredSymbol(candidateClass);

            if (classSymbol == null)
                continue;

            // Check if class has [GraphNodeHandler] attribute
            var attribute = classSymbol.GetAttributes()
                .FirstOrDefault(a => a.AttributeClass?.Name == "GraphNodeHandlerAttribute");

            if (attribute == null)
                continue;

            // Find the ExecuteAsync method with socket attributes
            var executeMethod = FindExecuteAsyncMethod(classSymbol);

            if (executeMethod == null)
                continue;

            // Generate bridge code
            var source = GenerateBridgeCode(classSymbol, executeMethod, attribute);
            var fileName = $"{classSymbol.Name}.Sockets.g.cs";

            context.AddSource(fileName, SourceText.From(source, Encoding.UTF8));
        }
    }

    private IMethodSymbol? FindExecuteAsyncMethod(INamedTypeSymbol classSymbol)
    {
        // Look for a method named ExecuteAsync that has parameters with [InputSocket]
        // or returns a type with properties marked with [OutputSocket]
        return classSymbol.GetMembers()
            .OfType<IMethodSymbol>()
            .FirstOrDefault(m => m.Name == "ExecuteAsync" && HasSocketAttributes(m));
    }

    private bool HasSocketAttributes(IMethodSymbol method)
    {
        // Check if any parameter has [InputSocket]
        foreach (var param in method.Parameters)
        {
            if (param.GetAttributes().Any(a => a.AttributeClass?.Name == "InputSocketAttribute"))
                return true;
        }

        // Check if return type has properties with [OutputSocket]
        if (method.ReturnType is INamedTypeSymbol returnType)
        {
            // Handle Task<T>
            if (returnType.Name == "Task" && returnType.TypeArguments.Length == 1)
            {
                var innerType = returnType.TypeArguments[0] as INamedTypeSymbol;
                if (innerType != null && HasOutputSocketProperties(innerType))
                    return true;
            }
        }

        return false;
    }

    private bool HasOutputSocketProperties(INamedTypeSymbol type)
    {
        return type.GetMembers()
            .OfType<IPropertySymbol>()
            .Any(p => p.GetAttributes().Any(a => a.AttributeClass?.Name == "OutputSocketAttribute"));
    }

    private string GenerateBridgeCode(INamedTypeSymbol classSymbol, IMethodSymbol executeMethod, AttributeData attribute)
    {
        var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
        var className = classSymbol.Name;
        var nodeName = GetNodeName(attribute, className);

        // Extract context type from first parameter or infer from base interface
        var contextType = InferContextType(classSymbol, executeMethod);

        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine($"namespace {namespaceName};");
        sb.AppendLine();
        sb.AppendLine($"partial class {className}");
        sb.AppendLine("{");

        // Generate HandlerName property if not already defined
        if (!HasHandlerNameProperty(classSymbol))
        {
            sb.AppendLine($"    public string HandlerName => \"{nodeName}\";");
            sb.AppendLine();
        }

        // Generate IGraphNodeHandler.ExecuteAsync implementation
        sb.AppendLine($"    async System.Threading.Tasks.Task<HPDAgent.Graph.Abstractions.Execution.NodeExecutionResult> HPDAgent.Graph.Abstractions.Handlers.IGraphNodeHandler<{contextType}>.ExecuteAsync(");
        sb.AppendLine($"        {contextType} context,");
        sb.AppendLine($"        HPDAgent.Graph.Abstractions.Handlers.HandlerInputs inputs,");
        sb.AppendLine($"        System.Threading.CancellationToken ct)");
        sb.AppendLine("    {");
        sb.AppendLine("        var stopwatch = System.Diagnostics.Stopwatch.StartNew();");
        sb.AppendLine("        try");
        sb.AppendLine("        {");

        // Extract inputs from HandlerInputs
        sb.AppendLine("            // Extract inputs from HandlerInputs");
        foreach (var param in executeMethod.Parameters)
        {
            if (param.Type.Name == "CancellationToken")
                continue;

            var inputAttr = param.GetAttributes()
                .FirstOrDefault(a => a.AttributeClass?.Name == "InputSocketAttribute");

            if (inputAttr != null)
            {
                var isOptional = GetAttributeProperty<bool>(inputAttr, "Optional");
                var paramName = param.Name;
                var paramType = param.Type.ToDisplayString();

                if (isOptional || param.HasExplicitDefaultValue)
                {
                    var defaultValue = param.HasExplicitDefaultValue
                        ? FormatDefaultValue(param.ExplicitDefaultValue, param.Type)
                        : $"default({paramType})";
                    sb.AppendLine($"            var {paramName} = inputs.GetOrDefault<{paramType}>(\"{paramName}\", {defaultValue});");
                }
                else
                {
                    sb.AppendLine($"            var {paramName} = inputs.Get<{paramType}>(\"{paramName}\");");
                }
            }
        }

        sb.AppendLine();
        sb.AppendLine("            // Call user's clean method");
        var methodCall = GenerateMethodCall(executeMethod);
        sb.AppendLine($"            var result = await {methodCall};");
        sb.AppendLine();
        sb.AppendLine("            stopwatch.Stop();");
        sb.AppendLine();

        // Build outputs dictionary from result
        sb.AppendLine("            // Build outputs from result");
        sb.AppendLine("            var outputs = new System.Collections.Generic.Dictionary<string, object>();");

        var returnType = GetTaskInnerType(executeMethod.ReturnType);
        if (returnType != null && returnType is INamedTypeSymbol namedReturnType)
        {
            var outputProperties = namedReturnType.GetMembers()
                .OfType<IPropertySymbol>()
                .Where(p => p.GetAttributes().Any(a => a.AttributeClass?.Name == "OutputSocketAttribute"))
                .ToList();

            foreach (var prop in outputProperties)
            {
                sb.AppendLine($"            outputs[\"{prop.Name}\"] = result.{prop.Name}!;");
            }
        }

        sb.AppendLine();
        sb.AppendLine("            return new HPDAgent.Graph.Abstractions.Execution.NodeExecutionResult.Success(");
        sb.AppendLine("                Outputs: outputs,");
        sb.AppendLine("                Duration: stopwatch.Elapsed");
        sb.AppendLine("            );");
        sb.AppendLine("        }");
        sb.AppendLine("        catch (System.Exception ex)");
        sb.AppendLine("        {");
        sb.AppendLine("            stopwatch.Stop();");
        sb.AppendLine("            return new HPDAgent.Graph.Abstractions.Execution.NodeExecutionResult.Failure(");
        sb.AppendLine("                Exception: ex,");
        sb.AppendLine("                Severity: IsTransientException(ex)");
        sb.AppendLine("                    ? HPDAgent.Graph.Abstractions.Execution.ErrorSeverity.Transient");
        sb.AppendLine("                    : HPDAgent.Graph.Abstractions.Execution.ErrorSeverity.Fatal,");
        sb.AppendLine("                IsTransient: IsTransientException(ex),");
        sb.AppendLine("                Duration: stopwatch.Elapsed");
        sb.AppendLine("            );");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();

        // Helper method to determine if exception is transient
        sb.AppendLine("    private static bool IsTransientException(System.Exception ex)");
        sb.AppendLine("    {");
        sb.AppendLine("        // Common transient exceptions");
        sb.AppendLine("        return ex is System.IO.IOException");
        sb.AppendLine("            || ex is System.Net.Http.HttpRequestException");
        sb.AppendLine("            || ex is System.TimeoutException;");
        sb.AppendLine("    }");

        sb.AppendLine("}");

        return sb.ToString();
    }

    private string GetNodeName(AttributeData attribute, string className)
    {
        var nodeName = GetAttributeProperty<string>(attribute, "NodeName");
        if (!string.IsNullOrEmpty(nodeName))
            return nodeName;

        // Convert PascalCase to snake_case
        return ToSnakeCase(className.Replace("Handler", ""));
    }

    private string ToSnakeCase(string text)
    {
        var sb = new StringBuilder();
        for (int i = 0; i < text.Length; i++)
        {
            var c = text[i];
            if (char.IsUpper(c) && i > 0)
                sb.Append('_');
            sb.Append(char.ToLower(c));
        }
        return sb.ToString();
    }

    private T? GetAttributeProperty<T>(AttributeData attribute, string propertyName)
    {
        var namedArg = attribute.NamedArguments.FirstOrDefault(a => a.Key == propertyName);
        if (namedArg.Value.Value is T value)
            return value;
        return default;
    }

    private string InferContextType(INamedTypeSymbol classSymbol, IMethodSymbol executeMethod)
    {
        // First check if method has a parameter that looks like context
        var contextParam = executeMethod.Parameters.FirstOrDefault(p =>
            p.Name.Contains("context", System.StringComparison.OrdinalIgnoreCase));

        if (contextParam != null)
            return contextParam.Type.ToDisplayString();

        // Check if class implements IGraphNodeHandler<TContext>
        foreach (var iface in classSymbol.AllInterfaces)
        {
            if (iface.Name == "IGraphNodeHandler" && iface.TypeArguments.Length == 1)
            {
                return iface.TypeArguments[0].ToDisplayString();
            }
        }

        // Default fallback
        return "HPDAgent.Graph.Abstractions.Context.IGraphContext";
    }

    private bool HasHandlerNameProperty(INamedTypeSymbol classSymbol)
    {
        return classSymbol.GetMembers("HandlerName")
            .OfType<IPropertySymbol>()
            .Any();
    }

    private ITypeSymbol? GetTaskInnerType(ITypeSymbol returnType)
    {
        if (returnType is INamedTypeSymbol namedType && namedType.Name == "Task" && namedType.TypeArguments.Length == 1)
        {
            return namedType.TypeArguments[0];
        }
        return null;
    }

    private string GenerateMethodCall(IMethodSymbol method)
    {
        var args = new List<string>();

        foreach (var param in method.Parameters)
        {
            if (param.Type.Name == "CancellationToken")
            {
                args.Add("ct");
            }
            else
            {
                args.Add(param.Name);
            }
        }

        return $"this.ExecuteAsync({string.Join(", ", args)})";
    }

    private string FormatDefaultValue(object? value, ITypeSymbol type)
    {
        if (value == null)
            return "null";

        if (type.SpecialType == SpecialType.System_String)
            return $"\"{value}\"";

        if (type.TypeKind == TypeKind.Enum)
            return $"{type.ToDisplayString()}.{value}";

        return value.ToString() ?? "null";
    }

    /// <summary>
    /// Syntax receiver that collects candidate classes for generation.
    /// </summary>
    private class SyntaxReceiver : ISyntaxReceiver
    {
        public List<ClassDeclarationSyntax> CandidateClasses { get; } = new List<ClassDeclarationSyntax>();

        public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
        {
            // Collect partial classes (required for source generation)
            if (syntaxNode is ClassDeclarationSyntax classDecl
                && classDecl.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword))
                && classDecl.AttributeLists.Count > 0)
            {
                CandidateClasses.Add(classDecl);
            }
        }
    }
}
