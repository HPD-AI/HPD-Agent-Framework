use std::ffi::{CStr, CString};
use hpd_rust_agent::ffi::{
    rust_create_agent, rust_create_conversation, rust_send_message,
    rust_free_string, rust_destroy_agent, rust_destroy_conversation
};
use hpd_rust_agent::agent::{AgentConfig, ProviderConfig, ChatProvider};
use serde_json::json;

fn main() {
    println!("ğŸ¤– HPD Rust Agent - Math Conversation Demo");
    println!("==========================================\n");

    // Create agent configuration with OpenRouter + Gemini 2.5 Pro
    let agent_config = AgentConfig {
        name: "Gemini Math Assistant".to_string(),
        system_instructions: r#"You are a helpful math assistant powered by Google's Gemini 2.5 Pro. 
You have access to several math functions that you MUST use when users ask you to perform calculations:

Available functions:
- add(a, b): Add two numbers
- subtract(a, b): Subtract b from a  
- multiply(a, b): Multiply two numbers
- divide(a, b): Divide a by b
- power(base, exponent): Raise base to the power of exponent
- sqrt(number): Calculate square root
- factorial(n): Calculate factorial of n
- is_prime(number): Check if a number is prime

When a user asks for a calculation, always use the appropriate function rather than calculating in your head. Show your work by explaining which function you're calling and why."#.to_string(),
        max_function_calls: 10,
        max_conversation_history: 20,
        provider: Some(ProviderConfig {
            provider: ChatProvider::OpenRouter,
            model_name: "google/gemini-2.5-pro".to_string(),
            api_key: Some("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".to_string()),
            endpoint: Some("https://openrouter.ai/api/v1".to_string()),
        }),
        plugin_configurations: None,
    };

    // Serialize config to JSON
    let config_json = serde_json::to_string(&agent_config).unwrap();
    let config_cstring = CString::new(config_json).unwrap();

    println!("ğŸ“‹ Creating agent with configuration:");
    println!("   Provider: OpenRouter");
    println!("   Model: Google Gemini 2.5 Pro");
    println!("   Functions: Math plugin enabled\n");

    // Create agent
    let agent_handle = unsafe { rust_create_agent(config_cstring.as_ptr()) };
    if agent_handle == 0 {
        eprintln!("âŒ Failed to create agent!");
        return;
    }
    println!("âœ… Agent created successfully! Handle: {}\n", agent_handle);

    // Create conversation
    let conversation_handle = unsafe { rust_create_conversation(agent_handle) };
    if conversation_handle == 0 {
        eprintln!("âŒ Failed to create conversation!");
        unsafe { rust_destroy_agent(agent_handle); }
        return;
    }
    println!("âœ… Conversation created! Handle: {}\n", conversation_handle);

    // Test different math problems
    let math_questions = vec![
        "What functions do you have?",
        "What is 156 + 847?",
        "Can you calculate 25 squared (25 to the power of 2)?",
        "What's the square root of 144?",
        "Calculate 120 divided by 8",
        "What is 15 times 23?",
        "Is 97 a prime number?",
        "What is the factorial of 5?",
        "Can you subtract 456 from 1000?",
    ];

    for (i, question) in math_questions.iter().enumerate() {
        println!("ğŸ§® Question {}: {}", i + 1, question);
        println!("{}", "â”€".repeat(50));

        let question_cstring = CString::new(*question).unwrap();
        
        // Send message to agent
        let response_ptr = unsafe { 
            rust_send_message(conversation_handle, question_cstring.as_ptr()) 
        };

        if response_ptr.is_null() {
            println!("âŒ Failed to get response from agent\n");
            continue;
        }

        // Get response
        let response_str = unsafe { CStr::from_ptr(response_ptr).to_str().unwrap() };
        
        // Try to parse as JSON to see if it contains function calls
        if let Ok(response_json) = serde_json::from_str::<serde_json::Value>(response_str) {
            println!("ğŸ“¨ Agent Response:");
            
            if let Some(message) = response_json.get("message") {
                println!("ğŸ’¬ Message: {}", message.as_str().unwrap_or("No message"));
            }
            
            if let Some(function_calls) = response_json.get("function_calls") {
                if let Some(calls_array) = function_calls.as_array() {
                    if !calls_array.is_empty() {
                        println!("ğŸ”§ Function Calls Made:");
                        for call in calls_array {
                            if let (Some(name), Some(args)) = (call.get("name"), call.get("arguments")) {
                                println!("   ğŸ“ Function: {}", name.as_str().unwrap_or("unknown"));
                                println!("   ğŸ“ Arguments: {}", args);
                                if let Some(result) = call.get("result") {
                                    println!("   âœ… Result: {}", result);
                                }
                            }
                        }
                    }
                }
            }
            
            if let Some(error) = response_json.get("error") {
                println!("âŒ Error: {}", error.as_str().unwrap_or("Unknown error"));
            }
        } else {
            // If not JSON, just print the raw response
            println!("ğŸ“¨ Raw Response: {}", response_str);
        }

        // Free the response
        unsafe { rust_free_string(response_ptr); }
        
        println!("\n{}\n", "â•".repeat(60));
    }

    // Cleanup
    println!("ğŸ§¹ Cleaning up...");
    unsafe {
        rust_destroy_conversation(conversation_handle);
        rust_destroy_agent(agent_handle);
    }
    println!("âœ… Demo completed successfully!");
}
